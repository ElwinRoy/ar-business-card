<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>AR Business Card</title>

<style>
  body {
    margin: 0;
    overflow: hidden;
    background: black;
    font-family: Arial, sans-serif;
  }

  #ui {
    position: fixed;
    top: 10px;
    left: 10px;
    right: 10px;
    display: flex;
    gap: 10px;
    align-items: center;
    z-index: 999;
    color: white;
  }

  button {
    padding: 10px 20px;
    font-size: 16px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-weight: bold;
  }

  #start {
    background: dodgerblue;
    color: white;
  }

  #reset {
    background: orange;
    color: white;
  }
</style>

<!-- THREE.JS CDN -->
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

</head>
<body>

<div id="ui">
  <span>Tap Start → Point at floor → Tap to place card</span>
  <button id="start">Start AR</button>
  <button id="reset">Reset</button>
</div>

<script>
let xrSession = null;
let gl = null;
let renderer = null;
let referenceSpace = null;
let hitTestSource = null;
let cardPlaced = false;

let scene, camera, card;

document.getElementById("start").addEventListener("click", startAR);
document.getElementById("reset").addEventListener("click", () => location.reload());

async function startAR() {
  if (!navigator.xr) {
    alert("WebXR not supported.");
    return;
  }

  const supported = await navigator.xr.isSessionSupported("immersive-ar");
  if (!supported) {
    alert("AR not supported on this device/browser.");
    return;
  }

  xrSession = await navigator.xr.requestSession("immersive-ar", {
    requiredFeatures: ["hit-test", "dom-overlay"],
    domOverlay: { root: document.body }
  });

  setupWebGL();
}

function setupWebGL() {
  const canvas = document.createElement("canvas");
  document.body.appendChild(canvas);

  gl = canvas.getContext("webgl", { xrCompatible: true });

  renderer = new THREE.WebGLRenderer({
    alpha: true,
    preserveDrawingBuffer: true,
    canvas: canvas
  });
  renderer.autoClear = false;

  xrSession.updateRenderState({
    baseLayer: new XRWebGLLayer(xrSession, gl)
  });

  xrSession.addEventListener("select", () => {
    cardPlaced = true;
    card.visible = true;
  });

  xrSession.requestReferenceSpace("viewer").then((viewerSpace) => {
    xrSession.requestHitTestSource({ space: viewerSpace })
      .then((source) => hitTestSource = source);
  });

  xrSession.requestReferenceSpace("local").then((refSpace) => {
    referenceSpace = refSpace;
    xrSession.requestAnimationFrame(onXRFrame);
  });

  setupScene();
}

function setupScene() {
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera();

  const texture = new THREE.TextureLoader().load("card.png");

  const geometry = new THREE.PlaneGeometry(0.15, 0.09);
  const material = new THREE.MeshBasicMaterial({
    map: texture,
    side: THREE.DoubleSide,
    transparent: true
  });

  card = new THREE.Mesh(geometry, material);
  card.visible = false;

  scene.add(card);
}

function onXRFrame(time, frame) {
  let session = frame.session;
  session.requestAnimationFrame(onXRFrame);

  const pose = frame.getViewerPose(referenceSpace);
  if (!pose) return;

  renderer.clear();

  const view = pose.views[0];
  const viewport = session.renderState.baseLayer.getViewport(view);
  renderer.setSize(viewport.width, viewport.height);

  camera.matrix.fromArray(view.transform.matrix);
  camera.projectionMatrix.fromArray(view.projectionMatrix);
  camera.updateMatrixWorld(true);

  if (!cardPlaced && hitTestSource) {
    const hits = frame.getHitTestResults(hitTestSource);

    if (hits.length > 0) {
      const hit = hits[0];
      const hitPose = hit.getPose(referenceSpace);

      card.visible = true;

      card.position.set(
        hitPose.transform.position.x,
        hitPose.transform.position.y,
        hitPose.transform.position.z
      );

      const ori = hitPose.transform.orientation;
      card.quaternion.set(ori.x, ori.y, ori.z, ori.w);
    }
  }

  renderer.render(scene, camera);
}
</script>

</body>
</html>
